Yes, but you don't need to "nag" them. You just need to design the UI so that filtering feels natural.

Here is the financial and UX reality of filtering before searching.



1. The Financial Truth: Filtering = Savings

Your code in js/transit.js has this critical line:

 code JavaScript

downloadcontent_copy

expand_less

    const visibleMics = STATE.mics.filter(mic => isMicVisible(mic));

  

This means the API call only asks for neighborhoods that are currently on screen.



Scenario A (No Filters): User looks at "All Mics Today."

Mics are scattered across 15 neighborhoods.

System caps it at 10.

Cost: $0.05 (Max).

Scenario B (User filters to "Free Mics"):

Free mics might only exist in 4 neighborhoods today.

System only asks Google for those 4.

Cost: $0.02 (60% Savings).

Scenario C (User filters to "After 10PM"):

Late night mics might only be in 2 neighborhoods (e.g., Greenwich Village & Bushwick).

System only asks Google for those 2.

Cost: $0.01 (80% Savings).

2. The UX Strategy: "Passive Encouragement"

You shouldn't put a popup that says "Please filter first to save me money." That feels cheap.

Instead, use these subtle design patterns:



A. The "Sort" Trigger (Best Approach)

Currently, your search bar acts as the trigger.



User: Types "Union Square."

App: Immediately calculates transit times.

Optimization:

Make "Distance/Time" a Sort Option, not just a default state.

User enters "Union Square."

App calculates distance (Free Math).

User sees a list sorted by distance.

User clicks a "Sort by Transit Time" button (or toggle).

THEN the API fires.

Why this is God-Tier:



Users who just want to see what's physically close (0.5 miles) get it instantly for $0.00.

Only users who are serious about traveling ("I need to know if the train is faster than walking") click the button, costing you $0.05.

B. Filter Accessibility

Ensure your Time/Price filters are visible on the same screen as the list, not hidden in a "More" menu.



If a user sees a "Free" chip or a "Late Night" chip, they will click it because it helps them, not to help you.

But the side effect is that it saves you money immediately.

3. What happens if they filter after searching?

This is a technical edge case you should handle in js/ui.js.



User: Searches "Union Square" (No filters).

Cost: $0.05 (Queries top 10 hubs).

Cache: You now have transit times for UWS, LES, East Village, etc. saved in memory.

User: Then clicks "Free Mics Only."

App: Updates the list.

Do you re-query?

NO. You already have the transit times cached from step 1!

The browser just re-renders the list using the data it already paid for.

The Verdict

Don't force it.

The most expensive action a user can take is Searching a Location.



If they filter before searching: You save money.

If they filter after searching: You paid full price ($0.05), but the app feels instant.

Both outcomes are acceptable given your $200 credit.

Recommendation:

Keep the UI simple. Let them search first if they want. The "10-Hub Cap" is your safety net, so you don't need to aggressive force filters to survive.  There are two different "Caps" here, and it is important not to confuse them:



The API Cap (Technical): The system only asks Google for the "top 10 closest neighborhoods."

The Commute Cap (User Preference): "I only want to travel 30 minutes."

Currently, your plan does not have a "Hide mics over 30 mins" button. Instead, it sorts the list so the fastest options are at the top.

Here is exactly what happens in your Trader Joe's on the UWS scenario.



The Scenario

You are here: Trader Joe's (72nd & Broadway, UWS).

Your Goal: "Show me what I can get to in 30 minutes."

System State: No filters active (showing all mics).

Step 1: The "10 Hub" Selection

The system calculates the distance from 72nd & Broadway to all 31 hubs. It picks the 10 closest to send to Google.



Likely Selection: UWS, Lincoln Square (Hell's Kitchen), Midtown, UES, Harlem, Chelsea, etc.

Excluded: Bushwick, Gowanus, Ridgewood.

Why this is fine: The hubs that were excluded (Bushwick) are physically impossible to reach in 30 minutes from the UWS anyway. You don't need Google to tell you that; the fallback math knows itâ€™s far.



Step 2: The Calculation

Nearby Mics (UWS/Midtown): The system asks Google. Google says: "A train is running express, 12 minutes to Times Square." (Blue Badge).

Far Mics (Bushwick): The system uses Math. Math says: "That is 8 miles away. ~55 minutes." (Gray Badge).

Step 3: The Result (What you see)

The app sorts the list by time.



1. Malelani Cafe (Washington Hts): ðŸ“ 15 min (Blue Badge)

2. Grisly Pear (Midtown): ðŸ“ 18 min (Blue Badge)

3. The Prod (Hell's Kitchen): ðŸ“ 22 min (Blue Badge)

4. Otto's Shrunken Head (Alphabet City): ðŸ“ 35 min (Blue Badge)

...

25. The Tiny Cupboard (Bushwick): ðŸ“ 55 min (Gray Badge)

So, what happens?

You don't "set" a 30-minute cap. You just stop scrolling.

The "10 Hub Cap" works perfectly here because any neighborhood within your 30-minute radius is guaranteed to be one of the closest 10 hubs. You will never have a situation where a venue is 20 minutes away but shows a "Gray Estimate" badge because it wasn't in the top 10.



Can we ADD a "30 Minute Cap" Button?

Technically, yes. You could add a filter dropdown: Max Travel: 30m.



Logic: mics.filter(m => m.transitMins <= 30)

Result: It would hide the Bushwick/Queens results entirely.

Recommendation: Don't build that button yet. Sorting is usually better UX because sometimes a user sees a venue that is 32 minutes away and decides "Eh, that's close enough." A hard filter would hide that option. Sorting lets the user decide their own pain threshold.Here is the breakdown of exactly how Googleâ€™s "Free Tier" works, the math behind the specific implementation plan I gave you, and how to guarantee you never pay a cent.



1. The "$200 Credit" Model

Google Maps Platform does not have a "Free Edition" and a "Pro Edition." Everyone uses the same Enterprise-grade API.

However, Google gives every billing account a recurring $200 USD credit every single month.



On the 1st of the month, your balance resets to $0.

The first $200 of usage is covered by Google.

You only pay if your usage exceeds $200.

2. The "Unit Cost" (The Element)

This is where people get confused. You are using the Distance Matrix API. Google does not charge per "API Call"; they charge per "Element."



An Element = 1 Origin 



        Ã—\times

Ã—

      

 1 Destination.

Price: $5.00 per 1,000 elements (Standard Rate).

3. The Math of Your App

In the code I provided (Phase 4), we filter the list of neighborhoods to the 10 closest hubs before asking Google for times.

Here is the cost of ONE button click by a user:



Origin: 1 (The user's location)

Destinations: 10 (The 10 closest hubs)

Total Elements: 



        1Ã—10=101 \times 10 = 10

1Ã—10=10

      

 elements.

Math: 10 elements 



        Ã—\times

Ã—

      

 (        5.00/1000)=âˆ—âˆ—5.00 / 1000) = **

5.00/1000)=âˆ—âˆ—

      

0.05**

Every time a user searches for transit, it "costs" $0.05.



4. How Many Searches are "Free"?

Now we apply the $200 monthly credit to your cost per search.



Monthly Budget: $200.00

Cost Per Search: $0.05

Total Searches: 



        200/0.05=4,000 searches200 / 0.05 = \mathbf{4,000 \text{ searches}}

200/0.05=4,000 searches

      

Daily Breakdown:



4,000 searches / 30 days 



        â‰ˆ\approx

â‰ˆ

      

 133 searches per day.

5. Why the Optimization was Critical

If we had not optimized the code (Phase 4) and sent all 31 neighborhoods to Google every time:



1 Search = 31 Elements

Cost = $0.155 per search

Capacity = ~1,290 searches per month

Daily Limit = Only 43 searches per day.

By filtering to the top 10, we tripled your free capacity.



6. How to Guarantee It stays Free (The "Hard Cap")

The fear is: "What if I go viral and get 10,000 searches overnight? I'll owe Google $300!"

You prevent this by setting a Quota Cap in the Google Cloud Console. This acts as a circuit breaker.



Go to Google Cloud Console > Google Maps Platform > Quotas.

Select Distance Matrix API.

Look for "Elements per day".

Set the limit to 1,300 (130 searches 



        Ã—\times

Ã—

      

 10 elements).

What happens if you hit the limit?



Google stops processing requests for the rest of the day.

You are charged $0.00.

Your app (because of the try/catch blocks we wrote) will automatically fail over to the Fallback Math (gray badges). The app keeps working, just slightly less accurate.

The next morning, the quota resets and blue badges return.

Summary

If you stick to the code I gave you (which limits queries to 10 hubs) and set your Daily Quota to 1,300 elements, you can run this feature effectively forever without paying a dime.