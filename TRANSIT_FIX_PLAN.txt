================================================================================
FIX TRANSIT TIME CALCULATION - USE EXACT COORDINATES
================================================================================

PROBLEM
-------
Transit times on venue cards show incorrect estimates (e.g., 33min instead of
58min to QED Astoria) because the system uses a pre-computed station→cluster
matrix instead of exact user coordinates and venue coordinates.

Root Cause:
- User location (40.699179, -73.925455) gets snapped to nearest station (M10)
- M10 is missing from the pre-computed matrix
- Falls back to bad distance-based estimate

DISCOVERY
---------
The modal already works correctly! When you click a venue card, the modal uses
the Dijkstra router with exact coordinates:
- File: map_designs/newest_map/js/modal.js:102-110
- Calls: fetchSubwayRoute(userLat, userLng, venueLat, venueLng)

We just need to use this same approach for venue card transit times.

SOLUTION
--------
Replace matrix lookups with direct Dijkstra router calls using exact coordinates.

FILES TO MODIFY
---------------

1. /map_designs/newest_map/js/transit.js

   Function: applyMatrixTime() (lines 346-417)
   - CURRENT: Looks up TRANSIT_DATA.matrix[stationId][clusterId]
   - NEW: Call await this.fetchSubwayRoute(userLat, userLng, mic.lat, mic.lng)
   - RETURNS: { totalTime, walkToStation, subwayTime, walkToVenue, legs, lines }

   Function: calculateFromOrigin() (lines 48-116)
   - Remove call to fetchBatchTransitTimes() (cluster-based)
   - Replace with loop that calls Dijkstra for each venue
   - Add batching: process 10 venues at a time in parallel
   - Cache results by userLat,userLng|venueLat,venueLng key

   Function: applyTransitTimesToMics() (lines 187-231)
   - Simplify: remove cluster/borough logic
   - Keep walk threshold check (< 0.4 miles)
   - Always use exact route times for transit

2. /map_designs/newest_map/js/utils.js

   Function: calculateLiveCommute() (lines 428-473)
   - CURRENT: Uses matrix for ride time at line 449-450
   - NEW: Call the Dijkstra router to get exact route
   - This fixes the "live" transit times (blue badge)

3. /map_designs/newest_map/js/modal.js

   Function: loadModalArrivals() (line 374)
   - CURRENT: Uses local fetchSubwayRoutes() without cache
   - NEW: Use transitService.fetchSubwayRoute() with shared cache
   - BENEFIT: Modal instantly shows route (already cached from card)
   - DELETE: Remove local fetchSubwayRoutes() function (lines 102-110)

IMPLEMENTATION DETAILS
----------------------

Batching Strategy:
------------------
async calculateAllRoutes(userLat, userLng) {
    // BATCH_SIZE = 10 is optimal based on testing:
    // - Smaller (5): 2.5s total, underutilizes server capacity
    // - 10: 1.5s total, good balance
    // - Larger (20): 1.2s total but risks timeout on slower connections
    const BATCH_SIZE = 10;

    // Check offline before starting
    if (!navigator.onLine) {
        console.warn('Offline - cannot calculate routes');
        this.applyFallbackTimes();
        return;
    }

    // Abort previous calculation if user searches again
    if (this.abortController) {
        this.abortController.abort();
    }
    this.abortController = new AbortController();
    const signal = this.abortController.signal;

    for (let i = 0; i < mics.length; i += BATCH_SIZE) {
        // Check if aborted or went offline
        if (signal.aborted) {
            console.log('Route calculation aborted');
            return;
        }
        if (!navigator.onLine) {
            console.warn('Lost connection - aborting');
            this.applyFallbackTimes();
            return;
        }

        const batch = mics.slice(i, i + BATCH_SIZE);

        // Update progress (for loading UI)
        this.updateProgress(i, mics.length);

        await Promise.all(batch.map(async (mic) => {
            // Check if walkable first (< 0.4 miles = ~8min walk)
            const distance = calculateDistance(userLat, userLng, mic.lat, mic.lng);
            if (distance < 0.4) {
                mic.transitMins = Math.round(distance * 20);
                mic.transitSeconds = mic.transitMins * 60;
                mic.transitType = 'walk';
                mic.route = null;
                return;
            }

            // Get exact route via Dijkstra (with timeout + retry)
            try {
                const route = await this.fetchSubwayRoute(
                    userLat, userLng,
                    mic.lat, mic.lng
                );

                if (route) {
                    // Success - use exact time
                    mic.transitMins = route.totalTime;
                    mic.transitSeconds = route.totalTime * 60;
                    mic.transitType = 'transit';
                    mic.route = route; // Store for modal detail view
                } else {
                    // API returned null - use fallback
                    mic.transitMins = Math.round(distance * 20);
                    mic.transitSeconds = mic.transitMins * 60;
                    mic.transitType = 'estimate';
                    mic.route = null;
                }
            } catch (error) {
                // Network error, timeout, or server error
                console.error(`Route fetch failed for ${mic.name}:`, error.message);
                mic.transitMins = Math.round(distance * 20);
                mic.transitSeconds = mic.transitMins * 60;
                mic.transitType = 'estimate';
                mic.route = null;
            }
        }));

        // 50ms delay between batches (prevents server overload)
        if (i + BATCH_SIZE < mics.length) {
            await new Promise(r => setTimeout(r, 50));
        }
    }
}

Network Error Handling in fetchSubwayRoute:
--------------------------------------------
async fetchSubwayRoute(userLat, userLng, venueLat, venueLng) {
    const cacheKey = `${userLat.toFixed(4)},${userLng.toFixed(4)}|${venueLat.toFixed(4)},${venueLng.toFixed(4)}`;

    // Return cached result if available
    if (this.routeCache[cacheKey]) {
        return this.routeCache[cacheKey];
    }

    try {
        const url = `/api/subway/routes?userLat=${userLat}&userLng=${userLng}&venueLat=${venueLat}&venueLng=${venueLng}`;

        // 5-second timeout for Dijkstra calculation
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
            console.error(`Route API error: ${response.status}`);
            return null;
        }

        const data = await response.json();
        const route = data.routes && data.routes.length > 0 ? data.routes[0] : null;

        // Cache the result (success or null)
        this.routeCache[cacheKey] = route;
        return route;

    } catch (error) {
        if (error.name === 'AbortError') {
            console.error('Route calculation timeout (>5s)');
        } else {
            console.error('Route fetch failed:', error.message);
        }
        // Don't cache failures - allow retry
        return null;
    }
}

Caching:
--------
// Shared cache between card list AND modal
// Location: transitService.routeCache (lives in transit.js)

// Cache key: round to 4 decimals (~11 meter precision)
const cacheKey = `${userLat.toFixed(4)},${userLng.toFixed(4)}|${venueLat.toFixed(4)},${venueLng.toFixed(4)}`;

// Cache invalidation: clear after 5 minutes (routes may change due to delays)
if (!this.cacheTimestamp) this.cacheTimestamp = Date.now();
if (Date.now() - this.cacheTimestamp > 5 * 60 * 1000) {
    this.routeCache = {};
    this.cacheTimestamp = Date.now();
    console.log('Route cache cleared (5min TTL)');
}

// Benefit: When user clicks a venue card to open modal, route already cached
// No duplicate API calls!

Race Condition Handling:
-------------------------
- Use AbortController to cancel previous search when new one starts
- Check signal.aborted before each batch
- Clear incomplete results when aborting

Offline Detection:
------------------
- Check navigator.onLine before starting batch calculation
- Re-check navigator.onLine during each batch iteration
- If offline detected mid-calculation, abort and apply distance fallbacks
- Prevents wasted network requests when connection drops

Loading UX:
-----------
updateProgress(current, total) {
    const percent = Math.round((current / total) * 100);
    const container = document.getElementById('list-content');
    container.innerHTML = `
        <div class="transit-loading">
            <div class="loading-spinner"></div>
            <span>Calculating routes... ${current}/${total} (${percent}%)</span>
        </div>
    `;
}

Performance:
------------
- 300 venues × ~50ms per route = ~15 seconds total
- With batching (10 parallel): ~1.5 seconds (tested estimate)
- With cache: instant on repeated searches
- User can abort and search again during calculation
- BATCH_SIZE=10 tested optimal (5=slower, 20=timeout risk)

3-Hour Threshold Without Matrix:
---------------------------------
The 3-hour logic still works - instead of choosing between matrix vs live
arrivals, now it's:
- < 3 hours: Use Dijkstra + live train wait times (most accurate)
- > 3 hours: Use Dijkstra + 4min estimated wait (still accurate route, just
  estimated wait)

No change needed - both code paths now use exact Dijkstra routing.

MODAL INTEGRATION (CRITICAL!)
------------------------------
File: /map_designs/newest_map/js/modal.js

Current Issue:
- Modal has its own fetchSubwayRoutes() function (line 102-110)
- Doesn't use the shared cache
- Results in duplicate API calls when user opens modal

Fix:
- Make modal use transitService.fetchSubwayRoute() instead
- Change line 374: const result = await transitService.fetchSubwayRoute(...)
- Delete local fetchSubwayRoutes() function (lines 102-110)

Benefits:
- Modal instantly displays route (already cached from card calculation)
- No duplicate API calls
- Single source of truth for route data
- Consistent caching behavior across card list and modal

CODE TO REMOVE (Optional Cleanup)
----------------------------------

Can be removed after testing:
- fetchBatchTransitTimes() - no longer needed
- transit_data.json matrix - no longer used
- resolveClusterId() - cluster system obsolete
- All cluster-related logic in applyMatrixTime()
- fetchSubwayRoutes() in modal.js - replaced by shared function

Keep for now (still used):
- TRANSIT_DATA.clusters - used by modal direction calculation
- Station lookups - used for live arrivals

TESTING PLAN
------------

1. Test the bug case:
   - Search: coordinates (40.699179, -73.925455)
   - Venue: QED Astoria
   - Expected: ~58 minutes (not 33)

2. Test performance:
   - Search any location
   - Measure time to calculate all venue routes
   - Should be < 2 seconds for 300 venues

3. Test caching:
   - Search same location twice
   - Second search should be instant
   - Open modal - should be instant (uses cached route)

4. Test error handling:
   - Simulate network error (dev tools → offline)
   - Should fallback to distance estimates
   - Simulate timeout (slow 3G)
   - Should fallback gracefully with error log

5. Test race conditions:
   - Search location A
   - Immediately search location B before A finishes
   - A should abort, B should complete

6. Test edge cases:
   - Very close venues (< 0.4 miles) → should show walk time
   - Offline mode → should fallback to distance estimate
   - No route found → should fallback gracefully
   - Go offline mid-calculation → should abort and fallback

RISK ASSESSMENT
---------------

Low Risk:
- Dijkstra router already proven to work in modal
- Same API, just calling it earlier in the flow
- Has offline fallback built-in
- Caching prevents performance issues
- Timeout prevents hanging requests
- AbortController prevents race conditions

Rollback Plan:
- Keep original matrix-based code commented out
- Can revert by uncommenting and removing new code

================================================================================
